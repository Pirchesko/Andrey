	.file	"Lab3.c"
	.section	.rodata						# секция данных только для чтения 
.LC0:
	.string	"Before: "
.LC1:
	.string	"%d; "
.LC2:
	.string	"..."
.LC3:
	.string	"Start sort..."
.LC4:
	.string	"Finish!"
.LC5:
	.string	"Time = %d\n"
.LC6:
	.string	"After: "
.LC7:
	.string	"...\n"
	.text									# поместить следующее в сегмент кода (команды работают только после .text) 
	.globl	main							# main - глобальный символ, видимый за пределами текущего файла 
	.type	main, @function					# main - функция (а не данные) 
main:
.LFB2:
	.cfi_startproc							# задаёт начало процедуры и устанавливает начальный регистр и смещение для расчёта адреса CFA (Canonical Frame Address) 
	leal	4(%esp), %ecx					# поместить в %ecx адрес предыдущего элемента в стеке
	.cfi_def_cfa 1, 0						# .cfi_def_cfa (регистр, смещение) определяет правило вычисления CFA как: принимать адрес из регистра и добавить к нему смещение 
	andl	$-16, %esp						# конъюкция числа -16 (11110000) *
	pushl	-4(%ecx)						# поместили на вершину стека значение  элемента в стеке -4*ecx 
	pushl	%ebp							# запоминаем текущее значение регистра %ebp (потом будем ссылаться на него) 
	.cfi_escape 0x10,0x5,0x2,0x75,0			# позволяет пользователю добавлять произвольные байты к информации раскрутки 
	movl	%esp, %ebp						# записываем текущее положение вершины стека
	pushl	%ecx							# кладём наверх стека значение %ecx 
	.cfi_escape 0xf,0x3,0x75,0x7c,0x6		# позволяет пользователю добавлять произвольные байты к информации раскрутки 
	subl	$480052, %esp					# резервируем место для локальных переменных вверх (скорее всего для массива) 
	movl	%gs:20, %eax					# заносим в %eax значение сегментного регистра (дополнительный сегментный регистр без специального назначения; в этих регистрах содержатся адреса ячеек памяти, с которых начинаются соответствующие сегменты )
	movl	%eax, -12(%ebp)					# заносим %gs в стек 
	xorl	%eax, %eax						# обнуляем 
	subl	$12, %esp						# поднимаемся выше 
	pushl	$1								# заносим единичку 
	call	srand							# вызываем системную функцию рандома с сидом 1
	addl	$16, %esp						# возращаемся вниз
	movl	$0, -480044(%ebp)				# начинаем цикл заполением рандомом (i=0)
	jmp	.L2
.L3:										# а тут заполнение цикла 
	call	rand
	movl	%eax, %edx						# eax(rand)=:edx 
	movl	-480044(%ebp), %eax				# eax=i 
	movl	%edx, -480012(%ebp,%eax,4)		# (%ebp + %eax*4 -480012) := %edx  massive[i] = rand()
	addl	$1, -480044(%ebp)				# i++ наверное сдвигаем ячейку на следующую 
.L2:
	cmpl	$119999, -480044(%ebp)			# поучается 0(i) - 119999 
	jle	.L3									# <= (проверка условия выполнения цикла)  
	subl	$12, %esp						# бежим по стеку 
	pushl	$.LC0							# пихаем строчку 
	call	printf							# выводим её 
	addl	$16, %esp						# вощращаемся в стек обратно 
	movl	$0, -480040(%ebp)				# начинается цикл вывода первых 5и элементов (i=0)
	jmp	.L4
.L5:
	movl	-480040(%ebp), %eax				# сейвим i-ое 
	movl	-480012(%ebp,%eax,4), %eax		# (%ebp + %eax*4 -480012) =: %eax присваеваем i-ое значение
	subl	$8, %esp						# поднимаемся на 8 вверх 
	pushl	%eax							# пихаем i-ый элемент на вывод 
	pushl	$.LC1							# берём строчку для вывода 
	call	printf							# выводим её 
	addl	$16, %esp						# спускаемся обратно 
	addl	$1, -480040(%ebp)				# смещаемся (делаем i+1) 
.L4:
	cmpl	$4, -480040(%ebp)				# 0 - 4 
	jle	.L5									# <= 
	subl	$12, %esp						# поднимаемся вверх 
	pushl	$.LC2							# берём строчку 
	call	puts							# обозначает вывод строки + символ "\n" 
	addl	$16, %esp						# спускаемся на 16 
	subl	$12, %esp						# поднимаемся на 12 
	pushl	$.LC3							# берём строчку 
	call	puts							# обозначает вывод строки + символ "\n" 
	addl	$16, %esp						# спускаемся на 16 
	call	clock							# вызываем системное время 
	movl	%eax, -480024(%ebp)				# в стеке фиксируем начало времени start = clock() 
	movl	$0, -480036(%ebp)				# начинается цикл сортировки i-ых элементов 
	jmp	.L6
.L10:
	movl	-480036(%ebp), %eax				# заносим значение i-ого элемента 
	movl	%eax, -480032(%ebp)				# j := i
	jmp	.L7
.L9:
	movl	-480036(%ebp), %eax				# берём i
	movl	-480012(%ebp,%eax,4), %edx		# высчитываем %edx := massive[i] 
	movl	-480032(%ebp), %eax				# берём j
	movl	-480012(%ebp,%eax,4), %eax		# %eax := massive[j] 
	cmpl	%eax, %edx						# сравниваем 
	jge	.L8									# >= (типо если не нужно менять местами скипаем следующие шаги) 
	movl	-480036(%ebp), %eax				# берём i
	movl	-480012(%ebp,%eax,4), %eax		# %eax := massive[i] 
	movl	%eax, -480020(%ebp)				# пихаем куда-то в резерв типо temp := massive[i] 
	movl	-480032(%ebp), %eax				# берём j
	movl	-480012(%ebp,%eax,4), %edx		# %edx := massive[j] 
	movl	-480036(%ebp), %eax				# берём i
	movl	%edx, -480012(%ebp,%eax,4)		# и по адресу massive[i] пихаем massive[j] 
	movl	-480032(%ebp), %eax				# берём j
	movl	-480020(%ebp), %edx				# записываем %edx := temp 
	movl	%edx, -480012(%ebp,%eax,4)		# massive[j] := temp(edx) 
.L8:
	addl	$1, -480032(%ebp)				# делаем j++ 
.L7:
	cmpl	$119999, -480032(%ebp)			# это проверка условия на j<N 
	jle	.L9
	addl	$1, -480036(%ebp)				# делаем i++ 
.L6:
	cmpl	$119999, -480036(%ebp)			# поучается 0 - 119999 (видимо i < N) 
	jle	.L10								# <= 
	call	clock							# вызваем ситемное время 
	movl	%eax, -480016(%ebp)				# фиксируем время finish = clock()
	subl	$12, %esp						# по стеку вверх 
	pushl	$.LC4							# выводми "Finish!" 
	call	puts							# делаем "\n" 
	addl	$16, %esp						# возращаемся обратно 
	movl	-480016(%ebp), %eax				# берём время finish =: %eax 
	subl	-480024(%ebp), %eax				# finish - start 
	subl	$8, %esp						# поднимаем стек 
	pushl	%eax							# записываем результат 
	pushl	$.LC5							# готовим строчку 
	call	printf							# вызываем вывод 
	addl	$16, %esp						# спускаемся на 16 
	subl	$12, %esp						# поднимаемся на 12 
	pushl	$.LC6							# выводим After: 
	call	printf							# вызываем вывод 
	addl	$16, %esp						# поднимаемся снова обратно 
	movl	$0, -480028(%ebp)				# начинаем цикл вывода 5и отсортированных элементов (i=0) 
	jmp	.L11
.L12:
	movl	-480028(%ebp), %eax				# %eax := i 
	movl	-480012(%ebp,%eax,4), %eax		# %eax := massive[i] 
	subl	$8, %esp						# поднимаемся чуть выше 
	pushl	%eax							# пихаем massive[i] видимо для вывода 
	pushl	$.LC1							# пушим строчку 
	call	printf							# вызываем системный вывод 
	addl	$16, %esp						# спускаемся на 16 
	addl	$1, -480028(%ebp)				# делаем i++ 
.L11:
	cmpl	$4, -480028(%ebp)				# 0 - 4 
	jle	.L12								# <= 
	subl	$12, %esp						# перемещаемся чуть выше 
	pushl	$.LC7							# вызываем строчку 
	call	puts							# пихаем строчку + "\n" 
	addl	$16, %esp						# возращаемся вниз 
	movl	$0, %eax						# %eax = 0 
	movl	-12(%ebp), %ecx					# вспомниаем про сегментный регистр %ecx = %gs:20 
	xorl	%gs:20, %ecx					# скорее всего проверяем уго равнество на обнулении 
	je	.L14								# и если они эквиваленты 
	call	__stack_chk_fail				# чекает переполнение стека ("Не проверяет переполнение стека. Он просто сообщает один при использовании")
.L14:
	movl	-4(%ebp), %ecx					# что-то системное записывает 
	.cfi_def_cfa 1, 0						# .cfi_def_cfa (регистр, смещение) определяет правило вычисления CFA как: принимать адрес из регистра и добавить к нему смещение 
	leave									# (movl %ebp %esp; pop %ebp)
	.cfi_restore 5							# .cfi_restore говорит, что правило для регистра теперь такое же, как и в начале функции, после того, как были выполнены все начальные инструкции, добавленные .cfi_startproc 
	leal	-4(%ecx), %esp					# орять вернули что-то на стек 
	.cfi_def_cfa 4, 4						# .cfi_def_cfa (регистр, смещение) определяет правило вычисления CFA как: принимать адрес из регистра и добавить к нему смещение 
	ret										# (pop %ecx; jmp %ecx) программа закончилась (return 0; в main) 
	.cfi_endproc							# закрывает свою запись очистки, ранее открытую .cfi_startproc, и передает ее в .eh_frame. 
.LFE2:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 5.5.0-12ubuntu1~16.04) 5.5.0 20171010"
	.section	.note.GNU-stack,"",@progbits

# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
# .eh_frame - предоставление дополнительной информации в среду выполнения для описания фреймов вызовов, которые должны быть размотаны во время обработки исключения 
# (*) При передаче управления процедуре микропроцессор автоматически записывает в вершину стека 4 байта. Эти байты являются адресом возврата в вызывающую программу. Если перед передачей управления процедуре командой call в стек были записаны переданные процедуре данные или указатели на них, то они окажутся под адресом возврата