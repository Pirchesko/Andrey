	.arch armv7-a
	.eabi_attribute 28, 1
	.fpu vfpv3-d16
	.eabi_attribute 20, 1
	.eabi_attribute 21, 1
	.eabi_attribute 23, 3
	.eabi_attribute 24, 1
	.eabi_attribute 25, 1
	.eabi_attribute 26, 2
	.eabi_attribute 30, 6
	.eabi_attribute 34, 1
	.eabi_attribute 18, 4
	.file	"Lab4.c"
	.section	.rodata
	.align	2
.LC0:
	.ascii	"Time = %d\012\000"
	.align	2
.LC1:
	.ascii	"Frist element in massive: %d\000"
	.text
	.align	2
	.global	main
	.syntax unified
	.thumb
	.thumb_func
	.type	main, %function
main:
	@ args = 0, pretend = 0, frame = 480032
	@ frame_needed = 1, uses_anonymous_args = 0
	push	{r4, r7, lr}						@сохраняем в стеке 3 регистра (lr ~ r14)
	sub	sp, sp, #479232							@sp=sp-479232
	sub	sp, sp, #804							@sp=sp-479232-804=sp-480036 возможно выделение памяти для программы
	add	r7, sp, #0								@r7=sp+0=sp (r7 - это верхняя граница)
	movw	r3, #:lower16:__stack_chk_guard		@какая-то защита стэка (возможно от переполнения) (записывает в последние 16 приемника)
	movt	r3, #:upper16:__stack_chk_guard		@какая-то защита стэка (возможно от переполнения) (записывает последние 16 источника в первые 16 приемника)
	ldr	r3, [r3]								@получаем значение из адреса r3 (получили непонять что(тупо какое-то рандомное значение))
	add	r2, r7, #479232							@r2=r7+479232
	add	r2, r2, #796							@r2=r2+796=r7+479232+796=r7+480028 (r2 - нижняя граница)
	str	r3, [r2]								@сохраняем значение r3(нечто странное) по адресу r2 (скорее всего фиксировать будет переполнение)
	movs	r0, #1								@r0=1 (Если указан S, флаги условий обновляются по результатам операции)
	bl	srand									@вызов функции srand (Инструкции B и BL выполняют переход на указанный адрес. BL, кроме того, сохраняет адрес возврата (адрес команды, следующей за BL) в регистре LR (R14))
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #796							@r3=r3-796=r7+4 [это адрес i]
	movs	r2, #0								@r2=0 (i=0)
	str	r2, [r3]								@записали нолик почти в самую верхнюю ячейку [r3]
	b	.L2										@примерно тут начинается цикл рандомного заполнения ячеек
.L3:
	bl	rand									@вызываем функцию рандома
	mov	r1, r0									@r1=r0=1 (возможно получили рандомное значение по умолчанию)
	add	r3, r7, #800							@r3=r7+800 (вниз)
	sub	r3, r3, #772							@r3=r3+772=r7+28 (вверх) (это начало: massive[0])
	add	r2, r7, #800							@r2=r7+800 (вниз)
	sub	r2, r2, #796							@r2=r2+796=r7+4 (вверх)
	ldr	r2, [r2]								@r2=i (забрала значение почти из самого вверха r7+4)
	str	r1, [r3, r2, lsl #2]					@сохраняем r1 (massive[i]) по адресу r3+r2*4 т.е. сохранили в r3+i*4(LSL предоставляет значение регистра, умноженное на степень двойки, вставляя нули в освобожденные битовые позиции)
	add	r3, r7, #800							@r3=r7+800 (вниз)
	sub	r3, r3, #796							@r3=r3+796=r7+4 (вверх)
	add	r2, r7, #800							@r2=r7+800 (вниз)
	sub	r2, r2, #796							@r2=r2+796=r7+4 (вверх)
	ldr	r2, [r2]								@r2=i
	adds	r2, r2, #1							@r2++ (i++)
	str	r2, [r3]								@сохраняем r2(i) по адресу r7+4
.L2:
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #796							@r3=r3-796=r7+4 (r3=i)
	ldr	r2, [r3]								@r2=i 
	movw	r3, #54463							@записали в последние 16 битиков 54463 (1101010010111111)
	movt	r3, 1								@(где #?) записали в первые 16 битиков единичку (0000000000000001)
	cmp	r2, r3									@сравниваем r2(i) и r3 (итого r3=00000000000000011101010010111111=119999)
	ble	.L3										@<=
	add	r4, r7, #800							@r4=r7+800
	sub	r4, r4, #784							@r4=r7+16 (start)
	bl	clock									@вызываем clock для стартового времени
	str	r0, [r4]								@записываем стартовое время в r7+16
	add	r3, r7, #800							@r3=r7+800 (тут анчинается сортировка пузырьком)
	sub	r3, r3, #792							@r3=r7+8 (адрес i)
	movs	r2, #0								@r2=0 (i=0)
	str	r2, [r3]								@сейвим r2(i) в r7+8
	b	.L4										@летим на проверку условия первого цикла
.L8:											@тутачки вложеный цикл сортирвки
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #788							@r3=r7+12 (возможный адрес j)
	add	r2, r7, #800							@r2=r7+800
	sub	r2, r2, #792							@r2=r7+8 (это адрес i)
	ldr	r2, [r2]								@r2=i
	str	r2, [r3]								@закидываем по адресу r7+12 значение r2 (j=i)
	b	.L5										@летим на проверку условия второго цикла
.L7:											@тут начинается swap
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #772							@r3=r7+28 (это начало: massive[0])
	add	r2, r7, #800							@r2=r7+800
	sub	r2, r2, #792							@r2=r7+8 (это адрес i)
	ldr	r2, [r2]								@r2=i
	ldr	r1, [r3, r2, lsl #2]					@r1=massive[i] (по адресу r3+i*4)
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #772							@r3=r7+28 (это начало: massive[0])
	add	r2, r7, #800							@r2=r7+800
	sub	r2, r2, #788							@r2=r7+12 (это адрес j)
	ldr	r2, [r2]								@r2=j
	ldr	r3, [r3, r2, lsl #2]					@r3=massive[j]=[r3+i*4]
	cmp	r1, r3									@сравниваем massive[i] и massive[j]
	bge	.L6										@=> (!<)
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #780							@r3=r7+20 (возможно это temp)
	add	r2, r7, #800							@r2=r7+800
	sub	r2, r2, #772							@r2=r7+28 (это начало (точка отсчета по координате i): massive[0])
	add	r1, r7, #800							@r1=r7+800
	sub	r1, r1, #792							@r1=r7+8 (это адрес i)
	ldr	r1, [r1]								@r1=i
	ldr	r2, [r2, r1, lsl #2]					@r2=massive[i] (по адресу r2+i*4)
	str	r2, [r3]								@temp=massive[i] (r7+20:=r2)
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #772							@r3=r7+28 (это начало (точка отсчета по координате i): massive[0])
	add	r2, r7, #800							@r2=r7+800
	sub	r2, r2, #788							@r2=r7+12 (это адрес j)
	ldr	r2, [r2]								@r2=j
	ldr	r1, [r3, r2, lsl #2]					@r1=massive[j] (по адресу r2+j*4)
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #772							@r3=r7+28 (это начало (точка отсчета по координате i): massive[0])
	add	r2, r7, #800							@r2=r7+800
	sub	r2, r2, #792							@r2=r7+8 (это адрес i)
	ldr	r2, [r2]								@r2=i
	str	r1, [r3, r2, lsl #2]					@massive[i]=massive[j] (сохраним r1=massive[j] по адресу r3+i*4=massive[i])
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #772							@r3=r7+28 (это начало (точка отсчета по координате i): massive[0])
	add	r2, r7, #800							@r2=r7+800
	sub	r2, r2, #788							@r2=r7+12 (это адрес j)
	ldr	r1, [r2]								@r1=massive[j]
	add	r2, r7, #800							@r2=r7+800
	sub	r2, r2, #780							@r2=r7+20 (это temp)
	ldr	r2, [r2]								@r2=temp
	str	r2, [r3, r1, lsl #2]					@massive[j]=temp (temp загружает в r3+j*4=massive[j])
.L6:
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #788							@r3=r7+12 (это j)
	add	r2, r7, #800							@r2=r7+800
	sub	r2, r2, #788							@r2=r7+12 (это i)
	ldr	r2, [r2]								@r2=j
	adds	r2, r2, #1							@r2++ (j++)
	str	r2, [r3]								@закидываем по адресу r7+12 значение j
.L5:
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #788							@r3=r7+12 (адрес j)
	ldr	r2, [r3]								@r2=j
	movw	r3, #54463							@записали в последние 16 битиков 54463 (1101010010111111)
	movt	r3, 1								@(где #?) записали в первые 16 битиков единичку (0000000000000001)
	cmp	r2, r3									@сравниваем r2(j) и r3 (итого r3=00000000000000011101010010111111=119999)
	ble	.L7										@<= (меняем местами)
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #792							@r3=r7+8 (адрес i)
	add	r2, r7, #800							@r2=r7+800
	sub	r2, r2, #792							@r2=r7+8 (адрес i)
	ldr	r2, [r2]								@r2=i
	adds	r2, r2, #1							@i++
	str	r2, [r3]								@закидываем по адресу r7+8 значение i
.L4:											@это первый цикл сортировки
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #792							@r3=r7+8 (адрес i)
	ldr	r2, [r3]								@r2=i
	movw	r3, #54463							@записали в последние 16 битиков 54463 (1101010010111111)
	movt	r3, 1								@(где #?) записали в первые 16 битиков единичку (0000000000000001)
	cmp	r2, r3									@сравниваем r2(i) и r3 (итого r3=00000000000000011101010010111111=119999)
	ble	.L8										@<=
	add	r4, r7, #800							@r4=r7+800
	sub	r4, r4, #776							@r4=r7+24 (finish)
	bl	clock									@выщываем функции clock
	str	r0, [r4]								@загружаем полученное время по адресу r7+24
	add	r2, r7, #800							@r2=r7+800
	sub	r2, r2, #776							@r2=r7+24
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #784							@r3=r7+16
	ldr	r2, [r2]								@r2=finish
	ldr	r3, [r3]								@r3=start
	subs	r3, r2, r3							@r3=r2-r3=finish-start
	mov	r1, r3									@r1=r3=количесву времени
	movw	r0, #:lower16:.LC0					@в r0 записываются первые 16 битиков строки
	movt	r0, #:upper16:.LC0					@в r0 записываются вторые 16 битиков строки
	bl	printf									@вызываем функцию printf
	add	r3, r7, #800							@r3=r7+800
	sub	r3, r3, #772							@r3=r7+28 (это massive[0])
	ldr	r3, [r3]								@r3=massive[0]
	mov	r1, r3									@r1=r3
	movw	r0, #:lower16:.LC1					@в r0 записываются первые 16 битиков строки
	movt	r0, #:upper16:.LC1					@в r0 записываются вторые 16 битиков строки
	bl	printf									@вызываем функцию printf
	movs	r3, #0								@r3=0
	mov	r0, r3									@r0=r3=0
	movw	r3, #:lower16:__stack_chk_guard		@какая-то защита стэка (возможно от переполнения) (записывает в последние 16 приемника)
	movt	r3, #:upper16:__stack_chk_guard		@какая-то защита стэка (возможно от переполнения) (записывает последние 16 источника в первые 16 приемника)
	add	r2, r7, #479232							@r2=r7+479232
	add	r2, r2, #796							@r2=r7+480028
	ldr	r2, [r2]								@r2=нечто странному что в начале было записано из __stack_chk_guard
	ldr	r3, [r3]								@r3=нечто странному что сейчас было записано из __stack_chk_guard
	cmp	r2, r3									@сравниваем и видимо выявляем утечку памяти или переполнение стека
	beq	.L10									@если они равны то скипем
	bl	__stack_chk_fail						@иначе у нас ошибка стека
.L10:
	add	r7, r7, #479232							@r7=r7+479232
	add	r7, r7, #804							@r7=r7+480036
	mov	sp, r7									@sp=r7 зачитска памяти
	@ sp needed
	pop	{r4, r7, pc}							@выпихиваем 3 регистра из стека
	.size	main, .-main
	.ident	"GCC: (Ubuntu/Linaro 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609"
	.section	.note.GNU-stack,"",%progbits

	@---------------------------------------------------------------------------
	@https://developer.arm.com/documentation/dui0068/b/arm-instruction-reference
	@http://microsin.net/programming/arm/asm-commands.html (ldr str)
	@https://developer.arm.com/documentation/dui0068/b/arm-instruction-reference/conditional-execution?lang=en
	@r7+4 - индекс i для заполения массива рандомом
	@r7+8 - индекс i для сортировки
	@r7+12 - индекс j для сортировки
	@r7+16 - start 
	@r7+20 - temp
	@r7+24 - finish
	@r7+28 - тут начинается массив massive[0]